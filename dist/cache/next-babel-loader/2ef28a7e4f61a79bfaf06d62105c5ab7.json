{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nvar __jsx = React.createElement;\nimport Button from '@material-ui/core/Button';\nimport { observer, useLocalStore } from 'mobx-react';\nimport React, { useCallback, useEffect, useRef } from 'react';\nimport SelectAlgorithm from '../components/SelectAlgorithm';\nimport SortMenu from '../components/SortMenu';\nimport SortSlider from '../components/SortSlider';\nimport ClassNames from '../utils/classnames';\nimport randomInRange from '../utils/randomInRange';\nimport { shuffle } from '../utils/shuffle';\nimport useSort from '../utils/sort/sort';\nimport createKey from '../utils/uuid';\nimport SortElement from '../components/SortElement';\nimport { sortsArray } from '../utils/sort/sort';\n\nvar delay = function delay(ms) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, ms);\n  });\n};\n\nexport var MAX_SORT_ELEMENTS = 85;\n\nvar Sort = function Sort(_ref) {\n  var _sortMenuRef$current;\n\n  var className = _ref.className;\n  className = ClassNames(className, 'Sort');\n  var state = useLocalStore(function () {\n    return {\n      elements: [],\n      speed: 1,\n      currentAlgorithm: 'merge-sort',\n      sorting: false\n    };\n  });\n  var sortMenuRef = useRef(null);\n  useEffect(function () {\n    onReset();\n  }, []);\n  var delayBySpeed = useCallback(function _callee() {\n    var first,\n        _args = arguments;\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            first = _args.length > 0 && _args[0] !== undefined ? _args[0] : true;\n            _context.t0 = state.speed;\n            _context.next = _context.t0 === 0 ? 4 : _context.t0 === 1 ? 7 : 12;\n            break;\n\n          case 4:\n            _context.next = 6;\n            return _regeneratorRuntime.awrap(delay(35));\n\n          case 6:\n            return _context.abrupt(\"break\", 17);\n\n          case 7:\n            _context.t1 = first;\n\n            if (!_context.t1) {\n              _context.next = 11;\n              break;\n            }\n\n            _context.next = 11;\n            return _regeneratorRuntime.awrap(delay(20));\n\n          case 11:\n            return _context.abrupt(\"break\", 17);\n\n          case 12:\n            _context.t2 = first;\n\n            if (!_context.t2) {\n              _context.next = 16;\n              break;\n            }\n\n            _context.next = 16;\n            return _regeneratorRuntime.awrap(delay(0));\n\n          case 16:\n            return _context.abrupt(\"break\", 17);\n\n          case 17:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }, [state.speed]);\n  var updateElements = useCallback(function (length) {\n    if (state.elements.length > length) {\n      state.elements = state.elements.slice(0, length);\n    } else if (state.elements.length < length) {\n      var diff = Math.abs(length - state.elements.length);\n      var newArray = Array(diff).fill(null).map(function () {\n        return {\n          value: Math.min(Math.floor(Math.random() * length) + 1, MAX_SORT_ELEMENTS),\n          key: createKey()\n        };\n      });\n      state.elements = [].concat(_toConsumableArray(state.elements), _toConsumableArray(newArray));\n    }\n  }, [state.elements]);\n  var onSort = useCallback(function _callee2() {\n    return _regeneratorRuntime.async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return _regeneratorRuntime.awrap(useSort(state, delayBySpeed));\n\n          case 2:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 3:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }, [state, state.speed, state.currentAlgorithm, state.elements, state.sorting]);\n  var cancelSort = useCallback(function () {\n    return state.sorting = false;\n  }, [state.sorting]);\n  var onReset = useCallback(function () {\n    cancelSort();\n\n    if (state.elements.length) {\n      shuffle(state.elements);\n    } else {\n      updateElements(randomInRange(20, MAX_SORT_ELEMENTS));\n    }\n  }, [state.elements]);\n  return __jsx(\"div\", {\n    className: className\n  }, __jsx(\"div\", {\n    className: \"titles\"\n  }, __jsx(\"h1\", null, \"Sorting Algorithm\"), __jsx(\"p\", null, \"Please select array size and choose algorithm\")), __jsx(\"div\", {\n    className: \"controls\"\n  }, __jsx(SortSlider, {\n    disabled: state.sorting,\n    value: state.elements.length,\n    updateElements: updateElements\n  }), __jsx(SelectAlgorithm, {\n    defaultValue: state.currentAlgorithm,\n    updateAlgo: function updateAlgo(algo) {\n      return state.currentAlgorithm = algo;\n    },\n    algorithms: sortsArray,\n    disabled: state.sorting\n  }), __jsx(Button, {\n    onClick: state.sorting ? cancelSort : onSort,\n    variant: \"contained\",\n    disabled: !state.currentAlgorithm,\n    color: state.sorting ? 'default' : 'primary'\n  }, state.sorting ? 'Pause' : 'Start!'), __jsx(Button, {\n    onClick: sortMenuRef === null || sortMenuRef === void 0 ? void 0 : (_sortMenuRef$current = sortMenuRef.current) === null || _sortMenuRef$current === void 0 ? void 0 : _sortMenuRef$current.handleClick,\n    variant: \"outlined\",\n    color: \"default\"\n  }, \"Settings\"), __jsx(SortMenu, {\n    array: state.elements,\n    onSpeedChanged: function onSpeedChanged(speed) {\n      return state.speed = speed;\n    },\n    speed: state.speed,\n    onReset: onReset,\n    ref: sortMenuRef\n  })), __jsx(\"div\", {\n    className: \"elements\"\n  }, state.elements.map(function (element) {\n    return __jsx(SortElement, element);\n  })));\n};\n\nexport default observer(Sort);","map":null,"metadata":{},"sourceType":"module"}